/*-
 * Copyright (c) 2007-2009 Robert N. M. Watson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD$
 */

#ifndef _NET_NETISR2_H_
#define	_NET_NETISR2_H_

#ifndef _KERNEL
#error "no user-serviceable parts inside"
#endif

/*-
 * Prototocols express flow and CPU affinities by implementing two functions:
 *
 * netisr_m2flow_t - When a packet without M_FLOWID is processed by netisr2,
 *                   it may call into the protocol to generate the missing
 *                   flow ID which should be installed in the packet header.
 *                   If a flow ID cannot be generated, or failure occurs,
 *                   NULL should be returned.
 *
 * netisr_flow2cpu_t - Given a flowid, possibly generated by netisr_m2flow,
 *                   and an optional source identifier (possibly a tid, pcb,
 *                   or kernel pointer), select a CPU to execute the packet
 *                   handler on.  If source isn't used, it will be 0/NULL.
 *
 * XXXRW: If we eventually support dynamic reconfiguration, there should be
 * protocol handlers to notify them of CPU configuration changes so that they
 * can rebalance work.
 */
typedef struct mbuf	*netisr_m2flow_t(struct mbuf *m);
typedef u_int		 netisr_flow2cpu_t(uintptr_t source, u_int flowid);

/*-
 * Register a new netisr2 handler for a given protocol.  No previous
 * registration may exist.
 *
 * proto        - Integer protocol identifier.
 * name         - Character string describing the protocol handler.
 * func         - Protocol handler.
 * m2flow       - Generate [missing] flowid for mbuf.
 * flow2cpu     - Convert a flowid to a CPU affinity.
 * max          - Maximum queue depth.
 */
void	netisr2_register(u_int proto, const char *name, netisr_t func,
	    netisr_m2flow_t m2flow, netisr_flow2cpu_t flow2cpu, u_int max);

/*
 * Deregister a protocol handler.
 */
void	netisr2_deregister(u_int proto);

/*
 * Process a packet destined for a protocol, and attempt direct dispatch.
 */
int	netisr2_dispatch(u_int proto, uintptr_t source, struct mbuf *m);
int	netisr2_queue(u_int proto, uintptr_t source, struct mbuf *m);

/*
 * Provide a default implementation of "map a flow ID to a cpu ID".
 */
u_int	netisr2_default_flow2cpu(uintptr_t source, u_int flowid);

/*
 * Utility routines to return the number of CPUs participting in netisr2, and
 * to return a mapping from a number to a CPU ID that can be used with the
 * scheduler.
 */
u_int	netisr2_get_cpucount(void);
u_int	netisr2_get_cpuid(u_int cpunumber);

#endif /* !_NET_NETISR2_H_ */
