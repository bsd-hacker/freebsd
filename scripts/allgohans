#!/bin/sh

pbc=${PORTBUILD_CHECKOUT:-/a/portbuild}
pbd=${PORTBUILD_DATA:-/a/portbuild}

. ${pbc}/conf/server.conf

if [ ! -z "${PORTBUILD_USER}" ]; then
    uid=${PORTBUILD_USER}
else
    uid=ports-${arch}
fi
if [ ! -z "${PORTBUILD_GROUP}" ]; then
    gid=${PORTBUILD_GROUP}
else
    gid=${uid}
fi

doarch() {
    arch=$1
    shift

    if [ ! -f "${pbd}/${arch}/portbuild.conf" ]; then
	echo "can't find ${pbd}/${arch}/portbuild.conf"
	exit 1
    fi

    machines=$(awk '{print $1}' ${pbd}/${arch}/mlist)

    for i in ${machines}; do
	. ${pbd}/${arch}/portbuild.conf
	if [ -f "${pbd}/${arch}/portbuild.${i}" ]; then
	    . ${pbd}/${arch}/portbuild.${i}
	fi
	if [ ${quiet} -eq 0 ]; then
	    echo "[$i]"
	fi
	cmdpath=${cmd}
	if [ ${scpfirst} -ne 0 ]; then
	    # If we need to scp first, the command given in the parameters is the local
	    # path, which we need to upload first. The command will return the remote
	    # temporary file, which we can subsequently execute. So this isn't really scp.
	    cmdpath=$(su ${uid} -c "cat ${cmd} | ${ssh_cmd} ${client_user}@$i 't=\$(mktemp -t ${cmd##*/}); cat >\$t; echo \$t; chmod 755 \$t'")
	    case ${cmdpath} in /tmp/*) ;; *) echo "Failed to scp ${cmd} to $i."; return 1;; esac
	fi
	lockf -t 60 ${pbd}/${arch}/lockfiles/lock.$i su ${uid} -c "${ssh_cmd} ${client_user}@$i ${sudo_cmd} ${cmdpath} $@"
	result=$?
	if [ $result -ne 0 ]; then
	    echo "could not execute command ${cmdpath} $@ on $i: $result"
	fi
	if [ ${scpfirst} -ne 0 ]; then
	    su ${uid} -c "${ssh_cmd} ${client_user}@$i 'rm -f ${cmdpath}'"
	fi
    done
}

arch=$1
if [ -z "${arch}" ]; then
	echo "usage: $0 <arch> [-q] [-scp]"
	exit 1
fi
shift

# XXX - Have to convert this to getopt().
if [ "$1" = "-q" ]; then
	quiet=1
	shift
else
	quiet=0
fi

if [ "$1" = "-scp" ]; then
	scpfirst=1
	shift
else
	scpfirst=0
fi

cmd=$1
shift

if [ "${arch}" = "all" ]; then
    arches=$(find ${pbd}/*/portbuild.conf)
    for i in ${arches}; do
	arch=$(basename $(dirname $i))
	doarch $arch "$@"
    done
else
    doarch $arch "$@"
fi
