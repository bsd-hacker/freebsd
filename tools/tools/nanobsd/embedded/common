# $FreeBSD$

#-
# Copyright (c) 2015 Warner Losh. All Rights Reserved.
# Copyright (c) 2010-2011 iXsystems, Inc., All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL iXsystems, Inc OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
#
# This file is heavily derived from both Sam Leffler's Avilia config,
# as well as the BSDRP project's config file.  Neither of these have
# an explicit copyright/license statement, but are implicitly BSDL. This
# example has been taken from the FreeNAS project (an early version) and
# simplified to meet the needs of the example.
#

# NB: You want the other file as the command line arg :)

# Missing in base:
# o mkimg setting active partition
# o mkimg starting at arbitrary offset (needed for A10, et al)
# o mtools still needed becuase we have no makefs -t msdos
# o nanobsd doesn't record changes to WORLDTEMP in customization
#   scripts yet, so we have kludge to pick up all files
# o easy way for pkg to grab files from other repos and put that
#   data on the image
# o Need to have some way to create / resize the s4 slice to do ping
#   pong bouncing between s3 and s4 for an arbitrary image. we can resize
#   one slice, not two
# o hints in the uboot ports for how to create the image
#
# Missing here
# o documentation for how to run the qemu images
# o msdos mtools fallback
# o special boot for !x86 !arm platforms
# o qemu image for arm
# o qemu image for aarch64
# o qemu image for armv6/armv7
# o easy support for different image / vm formats
# o need to promote much of this to nanobsd.sh and friends
# o uses old kludge to build image w/o ownership being right
#   for many files. Should move to mtree-dedup.awk.
# o support for EFI images
# o support for GPT partitioning
#
# Long Term
# o common tooling for creating images for odd-ball platforms
# o support for boot loaders other than uboot in the image
#   or via special insturctions
# o No pony support. Sadly, you cannot have a pony.
#

if [ -z $NANO_NAME ]; then
	echo "NANO_NAME not defined. Use foo.cfg instead."
fi

# Slice 1: FAT for ROM loading bootstrap
# Slice 2: Config partition
# Slice 3: FreeBSD partition (sized exactly)
# Slice 4: FreeBSD partition (empty)
# on first boot, we resize slice 3 & 4 to be 1/2 of what's
# left over on the SD card after slice 1 and 2 are taken
# off the top. We also resize the 'a' partion on first boot
# to the size of the partition for the ping/pong upgrade.
if [ -z "$EMBED_OMIT_FAT" ]; then
	NANO_SLICE_FAT=s1
	NANO_SLICE_CFG=s2
	NANO_SLICE_ROOT=s3
	NANO_SLICE_ALTROOT=s4
else
	NANO_SLICE_CFG=s1
	NANO_SLICE_ROOT=s2
	NANO_SLICE_ALTROOT=s3
fi	
NANO_SLICE_DATA=		# Not included

NANO_SLICE_FAT_SIZE=32m
NANO_SLICE_CFG_SIZE=32m

NANO_RAM_ETCSIZE=8192
NANO_RAM_TMPVARSIZE=8192
NANO_IMAGES=2

NANO_PMAKE="make -j $(sysctl -n hw.ncpu)"

NANO_CFG_BASE=$(pwd)
NANO_CFG_BASE=$(realpath ${NANO_CFG_BASE}/..)
NANO_SRC=$(realpath ${NANO_CFG_BASE}/../../..)
#### XXX share obj 
NANO_OBJ=${NANO_SRC}/../$NANO_NAME/obj
# Where cust_pkg() finds packages to install
#XXX: Is this the right place?
#NANO_PORTS=$(realpath ${NANO_SRC}/../ports)
NANO_PORTS=/usr/ports
NANO_PACKAGE_DIR=${NANO_SRC}/${NANO_TOOLS}/Pkg
NANO_INIT_IMG2=0
NANO_NOPRIV_BUILD=t
unset MAKEOBJDIRPREFIX

# this to go into nanobsd.sh
NANO_PORTS=${NANO_PORTS:-/usr/ports}

mkdir -p ${NANO_OBJ}

customize_cmd cust_allow_ssh_root

add_etc_make_conf()
{
	touch ${NANO_WORLDDIR}/etc/make.conf
}
customize_cmd add_etc_make_conf

cust_install_machine_files()
{
	echo "cd ${NANO_CFG_BASE}/Files"
	cd ${NANO_CFG_BASE}/Files
	find . -print | grep -Ev '/(CVS|\.svn|\.hg|\.git)' | cpio -dumpv ${NANO_WORLDDIR}
}
customize_cmd cust_install_files
customize_cmd cust_install_machine_files 

buildenv()
{
	cd ${NANO_SRC}
	env __MAKE_CONF=${NANO_MAKE_CONF_BUILD} DESTDIR=${NANO_WORLDDIR} make buildenv
}

NANO_MAKEFS="makefs -B big \
	-o bsize=4096,fsize=512,density=8192,optimization=space"
export NANO_MAKEFS

# NB: leave c++ enabled so devd can be built
CONF_BUILD="
WITHOUT_ACPI=true
WITHOUT_ATM=true
WITHOUT_AUDIT=true
WITHOUT_BIND_DNSSEC=true
WITHOUT_BIND_ETC=true
WITHOUT_BIND_LIBS_LWRES=true
WITHOUT_BLUETOOTH=true
WITHOUT_CALENDAR=true
WITHOUT_CVS=true
WITHOUT_DICT=true
WITHOUT_EXAMPLES=true
WITHOUT_FORTRAN=true
WITHOUT_GAMES=true
WITHOUT_GCOV=true
WITHOUT_GPIB=true
WITHOUT_HTML=true
WITHOUT_I4B=true
WITHOUT_IPFILTER=true
WITHOUT_IPX=true
WITHOUT_LIBKSE=true
WITHOUT_LOCALES=true
WITHOUT_LPR=true
WITHOUT_MAN=true
WITHOUT_NETCAT=true
WITHOUT_NIS=true
WITHOUT_NLS=true
WITHOUT_NS_CACHING=true
WITHOUT_OBJC=true
WITHOUT_PROFILE=true
WITHOUT_RCMDS=true
WITHOUT_SENDMAIL=true
WITHOUT_SHAREDOCS=true
WITHOUT_SYSCONS=true
WITHOUT_LIB32=true
"
CONF_INSTALL="$CONF_BUILD
INSTALL_NODEBUG=t
NOPORTDOCS=t
NO_INSTALL_MANPAGES=t
"
# The following would help...
# WITHOUT_TOOLCHAIN=true		can't build ports
# WITHOUT_INSTALLLIB=true		libgcc.a
#
# from the build
# WITHOUT_INFO=true			makeinfo
# WITHOUT_RCS=true
PKG_ONLY_MAKE_CONF="
WITHOUT_TOOLCHAIN=true
WITHOUT_INSTALLLIB=true
WITHOUT_INFO=true
WITHOUT_RCS=true
"

NANO_PACKAGE_ONLY=1

# install a package from a pre-built binary
do_add_pkg ()
{
	# Need to create ${NANO_OBJ}/ports in this add_pkg_${port} function
	set -x
	mkdir -p ${NANO_OBJ}/ports/distfiles
	mkdir -p ${NANO_OBJ}/ports/packages
	mkdir -p ${NANO_WORLDDIR}/usr/ports/packages
	mkdir -p ${NANO_WORLDDIR}/usr/ports/distfiles
	mount -t nullfs -o noatime ${NANO_OBJ}/ports/packages \
	    ${NANO_WORLDDIR}/usr/ports/packages
	mount -t nullfs -o noatime ${NANO_OBJ}/ports/distfiles \
	    ${NANO_WORLDDIR}/usr/ports/distfiles
	CR env ASSUME_ALWAYS_YES=YES SIGNATURE_TYPE=none /usr/sbin/pkg add /usr/ports/packages/All/$1.txz
	umount ${NANO_WORLDDIR}/usr/ports/distfiles
	umount ${NANO_WORLDDIR}/usr/ports/packages
	rmdir ${NANO_WORLDDIR}/usr/ports/packages
	rmdir ${NANO_WORLDDIR}/usr/ports/distfiles
	rmdir ${NANO_WORLDDIR}/usr/ports
	set +x
}

# Build a port (with the side effect of creating a package)
do_add_port ()
{
	local port_path
	port_path=$1
	shift
	set -x
	# Need to create ${NANO_OBJ}/ports in this add_port_${port} function
	mkdir -p ${NANO_OBJ}/ports/distfiles
	mkdir -p ${NANO_OBJ}/ports/packages
	mkdir -p ${NANO_PORTS}/packages
	mkdir -p ${NANO_PORTS}/distfiles
	mkdir -p ${NANO_WORLDDIR}/usr/src
	mkdir -p ${NANO_WORLDDIR}/usr/ports
      	mount -t nullfs -o noatime ${NANO_SRC} ${NANO_WORLDDIR}/usr/src
	mount -t nullfs -o noatime ${NANO_PORTS} ${NANO_WORLDDIR}/usr/ports
	mount -t nullfs -o noatime ${NANO_OBJ}/ports/packages \
	    ${NANO_WORLDDIR}/usr/ports/packages
	mount -t nullfs -o noatime ${NANO_OBJ}/ports/distfiles \
	    ${NANO_WORLDDIR}/usr/ports/distfiles
	mkdir -p ${NANO_WORLDDIR}/dev
	mount -t devfs devfs ${NANO_WORLDDIR}/dev
	mkdir -p ${NANO_WORLDDIR}/usr/workdir
	cp /etc/resolv.conf ${NANO_WORLDDIR}/etc/resolv.conf
	# OK, a little inefficient, but likely not enough to worry about.
	CR ldconfig /lib /usr/lib /usr/local/lib
	CR ldconfig -R
	CR ldconfig -r
# Improvement: Don't know why package-recursive don't works here
	CR "env UNAME_p=${NANO_ARCH} TARGET=${NANO_ARCH} \
	    TARGET_ARCH=${NANO_ARCH} PORTSDIR=${NANO_PORTS} make \
	    __MAKE_CONF=${NANO_MAKE_CONF_BUILD} \
	    WRKDIRPREFIX=/usr/workdir -C /usr/ports/$port_path \
	    package-recursive BATCH=yes $* clean FORCE_PKG_REGISTER=t"
	rm ${NANO_WORLDDIR}/etc/resolv.conf
	rm -rf ${NANO_WORLDDIR}/usr/obj
	rm -rf ${NANO_WORLDDIR}/usr/workdir
	umount ${NANO_WORLDDIR}/dev
	umount ${NANO_WORLDDIR}/usr/ports/packages
	umount ${NANO_WORLDDIR}/usr/ports/distfiles
	umount ${NANO_WORLDDIR}/usr/ports
	umount ${NANO_WORLDDIR}/usr/src
	set +x
}

# Need to check if this function works with cross-compiling architecture!!!!
# Recursive complex fonction: Generate one function for each ports
add_port () {
    local port_path=$1
    local port=`echo $1 | sed -e 's/\//_/'`
    shift
    # Check if package allready exist
    # Need to:
    # 1. check ARCH of this package!
    # 2. Add a trap
    cd ${NANO_PORTS}/${port_path}
    PKG_NAME=`env PORTSDIR=${NANO_PORTS} make __MAKE_CONF=${NANO_MAKE_CONF_BUILD} package-name` 
    if [ -f ${NANO_OBJ}/ports/packages/All/${PKG_NAME}.txz ]; then
	# Pkg file found: Generate add_pkg_NAME function
	eval "
	    add_pkg_${port} () {
	        do_add_pkg ${PKG_NAME}
	    }
            customize_cmd add_pkg_${port}
            "
    else
	# No pkg file: Generate add_port_NAME function
        eval "
            add_port_${port} () {
	        do_add_port ${port_path} $*
	    }
	    customize_cmd add_port_${port}
	"
	NANO_PACKAGE_ONLY=0
    fi
}

create_diskimage ( ) (
	local extra

	pprint 2 "build diskimage ${NANO_NAME}"
	pprint 3 "log: ${NANO_OBJ}/_.di"

	(
	if [ ! -z ${NANO_NOPRIV_BUILD} ]; then
	    extra="-F ${NANO_OBJ}/_.metalog"
	fi

	for i in s1 s2 s3 s4 empty; do
		rm -fr ${NANO_OBJ}/_.${i}*
	done

	if [ ! -z "${NANO_SLICE_FAT}" ]; then
		echo Creating MSDOS partition for kernel
		newfs_msdos -C ${NANO_SLICE_FAT_SIZE:-100m} -F 16 -L ${NANO_NAME} \
			${NANO_OBJ}/_.${NANO_SLICE_FAT}
	fi
	echo Creating main partition
	sz=${NANO_SLICE_ROOT_SIZE:+-s ${NANO_SLICE_ROOT_SIZE}}
	makefs ${extra} -B little $sz -t ffs ${NANO_OBJ}/_.${NANO_SLICE_ROOT}a "${NANO_WORLDDIR}"
	if [ -z "${NANO_CFGDIR}" ]; then
		echo "Faking cfg dir, it's empty"
		NANO_CFGDIR=${NANO_OBJ}/_.empty
		mkdir ${NANO_CFGDIR}
	fi
	echo Creating cfg parittion
# XXX -F cfg-mtree
	makefs -B little -t ffs -s ${NANO_SLICE_CFG_SIZE:-100m} \
		${NANO_OBJ}/_.${NANO_SLICE_CFG} "${NANO_CFGDIR}"
	# data slice not supported since we need the part for FAT for 
	# booting
	echo Slicing up the main partition into a full bsd part
	mkimg -s bsd -p freebsd-ufs:=${NANO_OBJ}/_.${NANO_SLICE_ROOT}a \
		-o ${NANO_OBJ}/_.${NANO_SLICE_ROOT}
	echo Making the whole shooting match
	if [ ! -z $NANO_SLICE_FAT ]; then
		eval $NANO_SLICE_FAT=fat16b
	fi
	eval $NANO_SLICE_CFG=freebsd
	eval $NANO_SLICE_ROOT=freebsd
	if [ ! -z "${NANO_SLICE_FAT}" ]; then
		mkimg -s mbr -p ${s1}:=${NANO_OBJ}/_.s1 \
			-p ${s2}:=${NANO_OBJ}/_.s2 \
			-p ${s3}:=${NANO_OBJ}/_.s3 \
			-o ${NANO_OBJ}/_.disk.image.${NANO_NAME}
	else
		# s1 is cfg, s2 is /, not sure how to make that
		# boot (marked as active) with mkimg yet
		mkimg -s mbr -p ${s1}:=${NANO_OBJ}/_.s1 \
			-p ${s2}:=${NANO_OBJ}/_.s2 \
			-o ${NANO_OBJ}/_.disk.image.${NANO_NAME}
	fi
	) > ${NANO_OBJ}/_.di 2>&1
)

die()
{
	echo "$*"
	exit 1
}

# Automatically include the packaging port here so it is always first so it
# builds the port and adds the package so we can add other packages.
#XXX Not sure this works for cross build, so punting for the moment
#add_port ports-mgmt/pkg
#add_port security/sudo
#add_port ftp/curl

rp=$(realpath ${NANO_OBJ}/)
__a=`mount | grep ${rp} | awk '{print length($3), $3;}' | sort -rn | awk '{$1=""; print;}'`
if [ -n "$__a" ]; then
    echo "unmounting $__a"
    umount $__a
fi

NANO_BOOTLOADER="boot/boot0"

if [ "$DEBUG" = 1 ]; then
	DEBUG_BUILD="
DEBUG_FLAGS=		-g
"
else
	DEBUG_INSTALL="
INSTALL_NODEBUG=	t
"
fi

CONF_INSTALL="$CONF_BUILD
${DEBUG_BUILD}
"
CONF_INSTALL="$CONF_INSTALL
${DEBUG_INSTALL}
"

if [ "${NANO_PACKAGE_ONLY}" -eq 1 ]; then
 	CONF_INSTALL="${CONF_INSTALL}
${PKG_ONLY_MAKE_CONF}
"
	echo "Automatically building a thin image with packages"
else
	echo "Automatically building a * * F A T * * image so we can build ports"
fi

VARS="MASTER_SITE_BACKUP MASTER_SITE_OVERRIDE PACKAGEROOT PACKAGESITE"

for var in $VARS; do
	val=$(eval echo "\$$var")
	if [ -n "$val" ]; then
		CONF_INSTALL="${CONF_INSTALL}
$var=$val"
	fi
done

hack_nsswitch_conf ( )
{
	# Remove all references to NIS in the nsswitch.conf file
	# Not sure this is still needed, but FreeNAS has it...
	sed -i.bak -es/nis/files/g ${NANO_WORLDDIR}/etc/nsswitch.conf
	rm -f ${NANO_WORLDDIR}/etc/nsswitch.conf.bak
}
customize_cmd hack_nsswitch_conf

save_build ( )
{
	VERSION_FILE=${NANO_WORLDDIR}/etc/version
	if [ "${SVNREVISION}" = "${REVISION}" ]; then
		echo "${NANO_NAME}" > "${VERSION_FILE}"
	else
		echo "${NANO_NAME} (${SVNREVISION})" > "${VERSION_FILE}"
	fi
}
customize_cmd save_build

remove_patch_divots ( )
{
	find ${NANO_WORLDDIR} -name \*.orig -or -name \*.rej -delete
}
customize_cmd remove_patch_divots

shrink_md_fbsize()
{
	# We have a lot of little files on our memory disks. Let's decrease
	# the block and frag size to fit more little files on them (this
	# halves our space requirement by ~50% on /etc and /var on 8.x --
	# and gives us more back on 9.x as the default block and frag size
	# are 4 times larger).
	sed -i '' -e 's,-S -i 4096,-S -i 4096 -b 4096 -f 512,' \
		${NANO_WORLDDIR}/etc/rc.initdiskless
}
customize_cmd shrink_md_fbsize

if [ "${DEBUG}" = 1 ]; then

unmute_console_logging()
{
	# /var is small. Don't fill it up with messages from console.log
	# because it's a chatty log.
	sed -i '' -e 's/#console.info/console.info/' \
			"${NANO_WORLDDIR}/etc/syslog.conf"
}
customize_cmd unmute_console_logging

fi

product_custom()
{
	if [ -z ${NANO_NOPRIV_BUILD} ]; then
		# Last second tweaks -- generally not needed
		chown -R root:wheel ${NANO_WORLDDIR}/root
		chmod 0755 ${NANO_WORLDDIR}/root/*
		chmod 0755 ${NANO_WORLDDIR}/*
		chown -R root:wheel ${NANO_WORLDDIR}/etc
		chown -R root:wheel ${NANO_WORLDDIR}/boot
		chown root:wheel ${NANO_WORLDDIR}/
		chown root:wheel ${NANO_WORLDDIR}/usr
	else
		# Construct an mtree after our messing around with the tree
		# Trim out all the uid / gid stuff, since for new files it
		# is likely wrong, and for other files it doesn't matter.
		mtree -p ${NANO_WORLDDIR} -c | \
			mtree -C | \
			sed -e 's/ uid=[0-9][0-9]* / /g;s/ gid=[0-9][0-9]* / /' \
			> ${NANO_OBJ}/_.mtree.post

		# Sort the metalog, and save the original. Sadly, this
		# seems to expand the uname= and gname= to uid= and gid=
		# which is lame and likely a bug in mtree. The man page
		# is just vague enough to be infuriating as to the proper
		# behavior. Happily, it removes all the // that can confound
		# things.
		mtree -C -S -f ${NANO_OBJ}/_.metalog > ${NANO_OBJ}/_.mtree.pre
		mv ${NANO_OBJ}/_.metalog ${NANO_OBJ}/_.metalog.install

		# mtree -f -f produces a comm-like output. The first column will
		# be the files we deleted, so we ignore it. The second column is
		# the same in both, so we pass it through. The third column is
		# listed twice, so we ignore the second one. We also trim out
		# the size, because size just doesn't matter as nanobsd and
		# customizations often tweak files changing their size.  We also
		# add 'optional' to every file in case something slipped through
		# that's gone from the tree, though maybe that's a real bug.
		#
		# To make matters worse, currently mtree in freebsd uses the
		# old 'file' keyword rather than the newer type=file. Ditto
		# dir and link. Also, nlinks is output, which is lame. And
		# there's a bloatload of extra flags=none, which I remove too.
		#
		# Even worse is that all the uid / gid stuff is also tossed
		# into the scrap heap. Hope they weren't important.
		#
		# And somewhere along the way, flags seem to have gone missing.
		#
		# Oh, and we have to add back in ./ to keep makefs happy.
		#
		# And then we have to sort the damn hing so directories come
		# before subdirectories
		#
		# Note: For reasons unknown, all the directories are changing
		# from 755 to 775, so that's why we ignore the second line.
		# We also get repeats for all the files whose size changed.
		# Perhaps we should filter those going into the pre/post files
		# and not here.
		mtree -f ${NANO_OBJ}/_.mtree.pre -f ${NANO_OBJ}/_.mtree.post | \
			awk '
				function frob_bogus_mtree_line(old) {
					line = "./" old " gid=0 uid=0"
					# XXX make this a damn function
					sub(/^\.\/\./, ".", line);
					sub(/ file /, " type=file ", line);
					sub(/ dir /, " type=dir ", line);
					sub(/ link /, " type=link ", line);
					sub(/ size=[0-9][0-9]*/, "", line);
					sub(/ nlinks=[0-9][0-9]*/, "", line);
					sub(/ flags=none*/, "", line);
					return line;
				}
				BEGIN {
					x = 0;
					FS="\t";
					print "#mtree 2.0";
				}
				$1 != "" {}
				$2 != "" {
					print frob_bogus_mtree_line($2);
				}
				$3 != "" {
					if (x == 0) {
						print frob_bogus_mtree_line($3);
						x = 1;
					} else {
						x = 0;
					}
				}
			' | sort > ${NANO_OBJ}/_.metalog
	fi
}
late_customize_cmd product_custom
